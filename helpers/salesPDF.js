const PDFDocument = require("pdfkit");

function exportSalesPDF(req, res, data, orders, filter, startDate, endDate) {
  try {
    const doc = new PDFDocument({ margin: 30, size: "A4", layout: "landscape" });

    // ---- Response headers ----
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", "attachment; filename=sales-report.pdf");
    doc.pipe(res);

    // ---- Title ----
    doc.fontSize(24).fillColor("#222").text("Sales Report", { align: "center" });
    doc.moveDown(0.5);

    // ---- Duration ----
    const durationText =
      filter === "custom"
        ? `Duration: ${startDate ? new Date(startDate).toISOString().split('T')[0] : '-'} to ${endDate ? new Date(endDate).toISOString().split('T')[0] : '-'}`
        : `Duration: ${filter ? filter.toUpperCase() : "ALL"}`;
    doc.fontSize(12).fillColor("gray").text(durationText, { align: "center" });
    doc.moveDown(0.5);

    // ---- Date From / To ----
    doc.fontSize(10).fillColor("#555")
      .text(`Start Date: ${startDate ? new Date(startDate).toISOString().split('T')[0] : '-'}`, { continued: true })
      .text(`     End Date: ${endDate ? new Date(endDate).toISOString().split('T')[0] : '-'}`);

    doc.moveDown(0.5);

    // ---- Generated By / On ----
    const generatedOn = new Date().toLocaleString("en-US", { hour12: true });
    doc.fontSize(10).fillColor("gray")
      .text(`Report generated by: Admin`, { align: "left" })
      .text(`Generated on: ${generatedOn}`, { align: "left" });
    doc.moveDown(0.5);

    // ---- Filter Applied ----
    doc.fontSize(10).fillColor("gray")
      .text(`Filter Applied: ${filter ? filter.toUpperCase() : "None"}`);
    doc.moveDown(1);

    // ---- Summary Section ----
    doc.fontSize(14).fillColor("#000").text("Summary", { underline: true });
    doc.moveDown(0.5);

    const salesSummary = [
      ["Total Orders", data.totalOrders],
      ["Products Sold", data.totalProductSold],
      ["Customers", data.totalCustomers],
      ["Cancelled Orders", data.totalCancelled],
      ["Returned Orders", data.totalReturned],
      ["Cancelled (Product)", data.totalProductCancelled],
      ["Returned (Products)", data.totalProductReturned],
      ["Discounts (Product)", data.totalDiscountPerProduct.toFixed(2)],
      ["Discounts (Order)", data.totalDiscountPerOrder.toFixed(2)],
      ["Total Revenue", data.totalRevenue.toFixed(2)],
      ["Total Refunds", data.totalRefund.toFixed(2)],
      ["AOV", data.AverageOrderValue.toFixed(2)],
    ];

    const tableStartX = 40;
    const tableStartY = doc.y;
    const colWidths = [150, 150];
    const rowHeight = 22;

    salesSummary.forEach(([label, value], index) => {
      const rowY = tableStartY + index * rowHeight;

      if (index % 2 === 0) {
        doc.rect(tableStartX, rowY, colWidths[0] + colWidths[1], rowHeight).fill("#f9f9f9");
      }

      doc.rect(tableStartX, rowY, colWidths[0], rowHeight).stroke("#ccc");
      doc.fontSize(12).fillColor("#000")
        .text(label, tableStartX + 5, rowY + 6, { width: colWidths[0] - 10, align: "left" });

      doc.rect(tableStartX + colWidths[0], rowY, colWidths[1], rowHeight).stroke("#ccc");
      doc.fillColor("#222")
        .text(value.toString(), tableStartX + colWidths[0] + 5, rowY + 6, { width: colWidths[1] - 10, align: "left" });
    });

    doc.y = tableStartY + salesSummary.length * rowHeight + 10;

    // ---- Detailed Orders Section ----
    doc.fontSize(16).fillColor("#000").text("Detailed Orders", { underline: true });
    doc.moveDown(0.5);

    const tableTop = doc.y;
    const detailedRowHeight = 32;
    const startX = 40;
    const colWidthsDetail = [90, 80, 100, 50, 70, 75, 75, 75, 75, 75];

    const headers = [
      "Order ID", "Date", "Customer", "Products", "Payment",
      "Status", "Subtotal", "Discount", "Coupon", "Total"
    ];

    // Draw header row
    let x = startX;
    headers.forEach((header, i) => {
      doc.rect(x, tableTop, colWidthsDetail[i], detailedRowHeight)
        .fillAndStroke("#f0f0f0", "#aaa");
      doc.fontSize(9).fillColor("#000").font("Helvetica-Bold")
        .text(header, x + 2, tableTop + 6, { width: colWidthsDetail[i] - 4, align: "center" });
      x += colWidthsDetail[i];
    });

    let y = tableTop + detailedRowHeight;

    // Draw rows
    orders.forEach((order, rowIndex) => {
      const orderDate = order.createdAt
        ? new Date(order.createdAt).toLocaleDateString("en-US", { day: "2-digit", month: "short", year: "numeric" })
        : "-";

      const subtotal = order.products.reduce(
        (s, p) => s + (p.basePrice || 0) * (p.quantity || 0),
        0
      );

      const row = [
        order.orderId || "-",
        orderDate,
        order.userId?.name || "-",
        order.products.reduce((s, p) => s + (p.quantity || 0), 0),
        order.payment?.method || "-",
        order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : "-",
        `${subtotal}+${order.deliveryCharge?+order.deliveryCharge:''}`,
        (order.products.reduce((s,product) =>s+(product.basePrice*product.quantity)-product.subtotal, 0) || 0).toFixed(2),
        order.couponDiscount ? ((order.totalOrderPrice*order.couponDiscount)/100).toFixed(2) : "No Coupon",
        (order.finalAmount || 0).toFixed(2),
      ];

      if (rowIndex % 2 === 0) {
        doc.rect(startX, y, colWidthsDetail.reduce((a, b) => a + b), detailedRowHeight).fill("#fafafa");
      }

      x = startX;
      row.forEach((value, i) => {
        doc.rect(x, y, colWidthsDetail[i], detailedRowHeight).stroke("#ccc");
        doc.fontSize(10).font("Helvetica").fillColor("#333")
          .text(value.toString(), x + 2, y + 6, { width: colWidthsDetail[i] - 4, align: "center", ellipsis: true });
        x += colWidthsDetail[i];
      });

      y += detailedRowHeight;

      if (y > doc.page.height - 80) {
        doc.addPage();
        y = 50;
      }
    });

    doc.end();
  } catch (err) {
    console.error("PDF export error:", err);
    res.status(500).send("Failed to export PDF");
  }
}

module.exports = exportSalesPDF;
